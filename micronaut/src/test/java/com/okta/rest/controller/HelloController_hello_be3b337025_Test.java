// ********RoostGPT********
/*
Test generated by RoostGPT for test java-junit4-test using AI Type Open AI and AI Model gpt-4

1. Positive Scenario: Test with a valid Principal object. 
   - Create a Principal object with a valid name.
   - Invoke the hello method with the Principal object.
   - Verify that the returned string is "Hello, [Principal's Name]!".

2. Negative Scenario: Test with a null Principal object. 
   - Invoke the hello method with a null Principal object.
   - Verify if the code handles null values correctly, possibly by returning a default message or throwing an appropriate exception.

3. Negative Scenario: Test with a Principal object having a null or empty name. 
   - Create a Principal object with a null or empty name.
   - Invoke the hello method with the Principal object.
   - Verify if the code handles such cases correctly, possibly by returning a default message or throwing an appropriate exception.

4. Positive Scenario: Test with a Principal object having a name containing special characters or numbers. 
   - Create a Principal object with a name containing special characters or numbers.
   - Invoke the hello method with the Principal object.
   - Verify that the returned string is "Hello, [Principal's Name]!".

5. Positive Scenario: Test with a Principal object having a long name. 
   - Create a Principal object with a long name.
   - Invoke the hello method with the Principal object.
   - Verify that the returned string is "Hello, [Principal's Name]!" and check if the function handles long names correctly.

6. Security Scenario: Test the function with and without security rules. 
   - Verify if the @Secured annotation works as expected. This includes testing with the user having the right permissions and with the user not having the right permissions.

7. Performance Scenario: Test the function with a large number of requests.
   - Verify if the function can handle a large number of requests without any performance degradation.
*/

// ********RoostGPT********
package com.okta.rest.controller;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.security.Principal;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;

public class HelloController_hello_be3b337025_Test {

    @InjectMocks
    HelloController helloController;

    @Mock
    Principal principal;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testHello_ValidPrincipal() {
        when(principal.getName()).thenReturn("John");
        String result = helloController.hello(principal);
        assertEquals("Hello, John!", result);
    }

    @Test(expected = NullPointerException.class)
    public void testHello_NullPrincipal() {
        helloController.hello(null);
    }

    @Test
    public void testHello_EmptyPrincipalName() {
        when(principal.getName()).thenReturn("");
        String result = helloController.hello(principal);
        assertEquals("Hello, !", result);
    }

    @Test
    public void testHello_SpecialCharacterPrincipalName() {
        when(principal.getName()).thenReturn("@John#");
        String result = helloController.hello(principal);
        assertEquals("Hello, @John#!", result);
    }

    @Test
    public void testHello_LongPrincipalName() {
        when(principal.getName()).thenReturn("JohnJohnJohnJohnJohnJohnJohnJohnJohnJohn");
        String result = helloController.hello(principal);
        assertEquals("Hello, JohnJohnJohnJohnJohnJohnJohnJohnJohnJohn!", result);
    }
}
